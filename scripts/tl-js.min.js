/**
 *@package tlBootstrap
 *@author thinolord
 *@version 1.0.5
 *@licence OpenGL
 *Important, il est recommandé de ne pas modifier le contenu de ce fichier pour bénéficier pleinement des avantages qu'elle offre. Vous pouvez contacter le développeur en cas de soucis
 *Ceci offre un accès simple au fonction de javascript ainsi que JQuery, il ne vaut pas plus que JQuery, mais il est beaucoup plus accessible et simple d'usage.
 *
*/

function tlprint (val) {
    console.log(val)
}
String.prototype.tlcase = function (kaz) {
    return this[kaz];
}
function _tlf () {
    let args = arguments
    let thiss = ``
    for (let k in this) {
        if (this.hasOwnProperty(k)) {
            thiss += `${this[k]}`
        }
    }
    for (let arg of args) {
        if (arg) {
            let mpos = thiss.search(/\*/)
            // tlprint(thiss.tlcase(mpos))
            if ( mpos > 0 ) {
                if (thiss.charAt(mpos-1) === "\\") return
            }
            thiss = thiss.replace(/\*/, arg)
        }
    }
    // tlprint(thiss)
    return `${thiss}`
}

function JSSend(method, url, data, callback) {
    var xhr = new XMLHttpRequest();
    var requestUrl = url;
    if (data instanceof thisFormData) {
        data = data.inputs
    }
    let Rdata = data
    if (method === 'GET' && data) {
        var params = new URLSearchParams();
        for (var key in data) {
            if (data.hasOwnProperty(key)) {
                params.append(key, data[key]);
            }
        }
        var queryString = params.toString();
        if (queryString) {
            requestUrl += '?' + queryString;
        }
    }
    xhr.open(method, requestUrl, true);
    xhr.onload = function() {
        if (xhr.status >= 200 && xhr.status < 400) {
            // var responseType = xhr.getResponseHeader('X-Response-Type');
            
            var contentType = xhr.getResponseHeader('Content-Type');
                if (contentType && contentType.includes('application/json')) {
                    // La réponse est au format JSON, analyser la réponse JSON
                    var responseJSON = JSON.parse(xhr.responseText);
                    // confirm("su?");
                    callback(true, responseJSON,contentType);
                } else {
                    callback(true, xhr.responseText,contentType);
                }
            } else {
                callback(false, xhr.responseText);
            }
        };
    xhr.onerror = function() {
        callback(false, "Une erreur s'est produite lors de la requête.");
    };
    if (method === 'POST') {
        if (Rdata instanceof FormData) {
            // xhr.setRequestHeader('Content-Type', 'multipart/form-data');
        }
        else {
            xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
        }
    }
    xhr.send(data);
}

class thisFormData {
    constructor(formId=null,excludeElements="") {
        if (formId instanceof HTMLElement) {
            this.form = formId;
        }
        else {
            this.form = formId ? document.querySelector(formId) : null;
        }
        this.inputs = new FormData();
        if (formId) {
            const inputElements = this.form.querySelectorAll('[name]');
            inputElements.forEach(input => {
                if (typeof this.excludeElements != "object") {
                    if (input != this.excludeElements) {
                        if (input.type !== 'submit' && input.type !== 'reset' && input.type !== 'button') {
                            if (input instanceof HTMLInputElement && input.type == "file") {
                                const name = input.name;
                                const files = input.files;
                                for (let file of files) {
                                    this.inputs.append(name,file);
                                }
                            }
                            else {
                                if (input instanceof HTMLInputElement || input instanceof HTMLTextAreaElement) {
                                    const value = input.value;
                                    const name = input.name;
                                    this.inputs.append(name,value);
                                }
                                else {
                                    const value = input.textContent;
                                    const name = input.getAttribute("name");
                                    this.inputs.append(name,value);
                                }
                                
                            }
                            
                        }
                        
                    }
                }
                else {
                    if (input.type !== 'submit' && input.type !== 'reset' && input.type !== 'button') {
                        for (var exinput of this.excludeElements) {
                            if (input != exinput) {
                                if (input instanceof HTMLInputElement && input.type == "file") {
                                    const name = input.name;
                                    const files = input.files;
                                    for (let file of files) {
                                        this.inputs.append(name,file);
                                    }
                                }
                                else {
                                    if (input instanceof HTMLInputElement || input instanceof HTMLTextAreaElement) {
                                        const value = input.value;
                                        const name = input.name;
                                        this.inputs.append(name,value);
                                    }
                                    else {
                                        const value = input.textContent;
                                        const name = input.getAttribute("name");
                                        this.inputs.append(name,value);
                                    }
                                }
                            }
                        }
                    }
                }
                
            });
        }
        // return this.inputs;
    }

    add (name, value) {
        this.inputs.append(name,value);
    }
}

function Jsend(method, url, data) {
    return new Promise(async (resolve, reject) => {
        try {
            let response;
            if (method === 'GET') {
                let params = new URLSearchParams();
                for (let key in data) {
                    if (data.hasOwnProperty(key)) {
                        params.append(key, data[key]);
                    }
                }
                const queryString = params.toString();
                if (queryString) {
                    url += '?' + queryString;
                }

                response = await fetch(url);
            } else {
                response = await fetch(url, {
                    method: method,
                    body: data,
                });
            }
            
            if (!response.ok) {
                throw new Error(`HTTP error! Status: ${response.status}`);
            }
            
            const contentType = response.headers.get('Content-Type');
            let responseData;
            
            if (contentType && contentType.includes('application/json')) {
                responseData = await response.json();
            } else {
                responseData = await response.text();
            }
            
            resolve(responseData);
        } catch (error) {
            reject(error.message);
        }
    });
}

function styleThis(property, value) {
    if (this instanceof NodeList) {
        this.forEach((each)=>{
            each.style[property] = value;
        });
    }
    else {
        this.style[property] = value;
    }
}
function futureBuilder (duration) {
    return new Promise(resolve => {
        setTimeout (()=>{
            resolve()
        },duration)
    })
}
function stylesThis(styleMap) {
    if (typeof styleMap == "object") {
        for (var key in styleMap) {
            if (styleMap.hasOwnProperty(key)) {
                if (this instanceof NodeList) {
                    this.forEach((each)=>{
                        each.style[key] = styleMap[key];
                    });
                }
                else {
                    this.style[key] = styleMap[key];
                } 
            }
        }
        
    }
    else {
        new Error("stylesThis() parameter should be an object")
    }
    
}

function formatTempsEcoule(dateStr) {
    const maintenant = new Date();
    const date = new Date(dateStr);

    const differenceEnMilliseconds = maintenant - date;
    const secondes = Math.floor(differenceEnMilliseconds / 1000);
    const minutes = Math.floor(secondes / 60);
    const heures = Math.floor(minutes / 60);
    const jours = Math.floor(heures / 24);
    const mois = Math.floor(jours / 30); // Approximation, peut être ajustée selon les besoins
    const annees = Math.floor(jours / 365); // Approximation, peut être ajustée selon les besoins

    if (annees > 0) {
        return `il y a plus de ${annees} an${annees > 1 ? 's' : ''}`;
    } else if (mois > 0) {
        return `il y a plus de ${mois} mois`;
    } else if (jours > 0) {
        return `il y a plus de ${jours} jour${jours > 1 ? 's' : ''}`;
    } else if (heures > 0) {
        return `il y a plus de ${heures} heure${heures > 1 ? 's' : ''}`;
    } else if (minutes > 0) {
        return `il y a ${minutes} minute${minutes > 1 ? 's' : ''}`;
    } else {
        return `il y a ${secondes} seconde${secondes > 1 ? 's' : ''}`;
    }
}

// // Exemple d'utilisation avec une date au format "2023-12-09 14:35:52"
// const dateStr = "2023-12-09 14:35:52";
// const tempsEcoule = formatTempsEcoule(dateStr);
// console.log(tempsEcoule);

class ExternalStorage {
    constructor(apiUrl) {
      this.apiUrl = apiUrl;
    }
  
    setItem(keys, value) {
        const data = {};
        if (typeof keys == 'object') {
            
            for (var k = 0; k < keys.length ;k++) {
                data[keys[k]] = value[k];
            }
        }
        else {
            data[keys] = value
        }
        
        JSSend(
            'POST',
            this.apiUrl,
            factoriString(data),
            (success,response)=>{
                var valueExpet = '';
                if (success) {
                    
                    valueExpet = response.message;
                    // //console.log(data.factoriString())
                    return valueExpet;
                }
                else {
                    valueExpet = null;
                }
            }
        );
    //   return await fetch(this.apiUrl, {
    //     method: 'POST',
    //     headers: {
    //       'Content-Type': 'application/json',
    //     },
    //     body: JSON.stringify(data),
    //   }).then((response) => response.json());
    }
  
    getItem (key) {
        // var valueExpet = "";
        // var dataTosend = {};
        // dataTosend[key] = "";
        // JSSend(
        //     'GET',
        //     this.apiUrl,
        //     dataTosend,
        //     (success,response)=>{
        //         if (success) {
                    
        //             valueExpet = response.message;
        //             return valueExpet;
        //         }
        //         else {
        //             valueExpet = null;
        //         }
        //     }

        // );
        // return valueExpet;
        return fetch(`${this.apiUrl}?${key}=""`)
            .then((response) => response.json())
            .then((data) => {
                if (data.status) {
                    return data.message;
                } else {
                    return null;
                }
            });
        }
    
  }
function factoriString(obj) {
    var queryString = "";
    for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
            if (queryString !== "") {
                queryString += "&";
            }
            queryString += encodeURIComponent(key) + "=" + encodeURIComponent(obj[key]);
        }
    }
    return queryString;
}

function stringfyParam(obj, separator = "", addArg = false) {
    var queryString = "";
    var decomp = 0;
    for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
            if (queryString !== "") {
                queryString += separator;
            }
            if (decomp === 0 && addArg) {
                queryString += "?";
                decomp++;
            }
            queryString += encodeURIComponent(key) + "=" + encodeURIComponent(obj[key]);
        }
    }
    return queryString;
}

function simpleStringingMap(obj, separator = "&") {
    var queryString = "";
    for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
            if (queryString !== "") {
                // queryString += separator
                queryString += `&${key}=${obj[key]}`;
            }
            else {
                queryString += `${key}=${obj[key]}`;
            }
            
            // //console.log(`&${key}=${obj[key]}`)
        }
    }
    return queryString;
}

function stringfyThis(obj) {
    var queryString = "";
    for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
            if (queryString !== "") {
                queryString += " ";
            }
            queryString += obj[key];
        }
    }
    return queryString;
}

function thisVal() {
    return this.value;
}

// Convertir "xxx-xxx" en "xxxXxx"
function removeTiretAndUpper(chaine) {
    // Séparer la chaîne en trois parties en fonction du tiret
    var parties = chaine.split('-');

    if (parties.length == 1) {
        return
    }
    else {
        // Concaténer les parties avec la première lettre en majuscule pour les deuxième et troisième parties
        return parties[0] + parties[1][0].toUpperCase() + parties[1].slice(1) + parties[2];
    }
}

// Supprimer tous les tirets pour obtenir "xxxxxx"
function removeTiret(chaine) {
    return chaine.replace(/-/g, '');
}

// Définition des expressions régulières directement dans un objet séparé
const cryptoRe = {
    bitcoin: /^(1|3)[a-km-zA-HJ-NP-Z1-9]{25,34}$|^bc1[a-z0-9]{30,59}$/,
    ethereum: /^(0x[a-fA-F0-9]{40})$/,
    ripple: /^(r[0-9a-zA-Z]{24,34})$/,
    litecoin: /^(L[a-km-zA-HJ-NP-Z1-9]{25,33})|(M[a-km-zA-HJ-NP-Z1-9]{25,33})$/,
    tron: /^(T[0-9a-zA-Z]{33})|(T[0-9a-zA-HJ-NP-Z1-9]{34})$/,
    babydoge: /^(0x)?[a-fA-F0-9]{40}$/,
    binancecoin: /^(bnb1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{39})$/,
    binanceUsd: /^(0x[a-fA-F0-9]{40})$/,
    tether: /^(T[a-zA-Z0-9]{33})$/,  // Tether TRC-20
    cardano: /^(addr1[qpzry9x8gf2tvdw0s3jn54khce6mua7l]{38})$/,
    usdcoin: /^(0x[a-fA-F0-9]{40})$/,
    dogecoin: /^(D[1-9A-HJ-NP-Za-km-z]{33})|(Q[1-9A-HJ-NP-Za-km-z]{33})|(V[1-9A-HJ-NP-Za-km-z]{33})$/,
    shibainu: /^(0x[a-fA-F0-9]{40})$/
};

// Ajout de méthodes au prototype de String pour valider les adresses
String.prototype.isBitcoin = function() {
    return cryptoRe.bitcoin.test(this);
};

String.prototype.isEthereum = function() {
    return cryptoRe.ethereum.test(this);
};

String.prototype.isRipple = function() {
    return cryptoRe.ripple.test(this);
};

String.prototype.isLitecoin = function() {
    return cryptoRe.litecoin.test(this);
};

String.prototype.isTron = function() {
    return cryptoRe.tron.test(this);
};

String.prototype.isBabydoge = function() {
    return cryptoRe.babydoge.test(this);
};

String.prototype.isBinanceCoin = function() {
    return cryptoRe.binancecoin.test(this);
};

String.prototype.isBinanceUsd = function() {
    return cryptoRe.binanceUsd.test(this);
};

String.prototype.isTether = function() {
    return cryptoRe.tether.test(this);
};

String.prototype.isCardano = function() {
    return cryptoRe.cardano.test(this);
};

String.prototype.isUsdCoin = function() {
    return cryptoRe.usdcoin.test(this);
};

String.prototype.isDogecoin = function() {
    return cryptoRe.dogecoin.test(this);
};

String.prototype.isShibaInu = function() {
    return cryptoRe.shibainu.test(this);
};

// // Exemple d'utilisation
// const testResultBitcoin = "adresse_bitcoin".CryptoRegex.testBitcoin();
// const testResultEthereum = "adresse_ethereum".CryptoRegex.testEthereum();
// const testResultRipple = "adresse_ripple".CryptoRegex.testRipple();
// // ... et ainsi de suite pour les autres cryptomonnaies

// //console.log(testResultBitcoin); // true ou false
// //console.log(testResultEthereum); // true ou false
// //console.log(testResultRipple); // true ou false
// // ... et ainsi de suite pour les autres cryptomonnaies


HTMLElement.prototype.styleThis = styleThis;
NodeList.prototype.styleThis = styleThis;
HTMLElement.prototype.stylesThis = stylesThis;
NodeList.prototype.stylesThis = stylesThis;
HTMLElement.prototype.thisVal = thisVal;

/**
 * 
 * @param {string} query 
 * @param {string} actionEvent 
 * @param {any} action 
 * @param {bool} once 
 * @returns {null | HTMLElement | NodeList | void}
 */
function Qs(query, actionEvent = null, action = null,once = false) {
    var tagElement = ['form','div','section','ul','li','h1','h2','h3','h4','h5','h6','input','label','button','html','img']
    if (actionEvent === null || action === null) {
        if (query[0] == '.' || query[0] == '#') {
            if (query[0] == '#') {
                var element = document.querySelector(query);
            }
            else {
                var element = document.querySelectorAll(query);
            }   
        }
        else if (tagElement.includes(query)) {
            var element = document.querySelectorAll(query)
        }
        else{
            var element = document.querySelector('.'+query);
        }
        return element;
    }
    
    else{
        if (once) {
            if (query[0] == '#') {
                var element = document.querySelector(query);
                if (element) {
                    element.addEventListener(actionEvent, (ev) => action.call(element, element,ev),{once:true});
                }
            }
            else{
                var elements = document.querySelectorAll(query);
                if (elements && elements.length > 0) {
                    elements.forEach((element)=>{
                        element.addEventListener(actionEvent, (ev) => action.call(element, element,ev),{once:true});
                    });
                }
            }
        }
        else {
            if (query[0] == '#') {
                var element = document.querySelector(query);
                if (element) {
                    element.addEventListener(actionEvent, (ev) => action.call(element, element,ev));
                }
            }
            else{
                var elements = document.querySelectorAll(query);
                if (elements && elements.length > 0) {
                    elements.forEach((element)=>{
                        element.addEventListener(actionEvent, (ev) => action.call(element, element,ev));
                    });
                }
            }
        }
    }
}

function QSs (query, actionEvent = null, action = null,once= false) {
    var tagElement = ['form','div','section','ul','li','h1','h2','h3','h4','h5','h6','input','label','button','html','img']
    if (actionEvent === null || action === null) {
        if (query[0] == '.' || query[0] == '#') {
            if (query[0] == '#') {
                var element = this.querySelector(query);
            }
            else {
                var element = this.querySelectorAll(query);
            }   
        }
        else if (tagElement.includes(query)) {
            var element = this.querySelectorAll(query)
        }
        else{
            var element = this.querySelector('.'+query);
        }
        return element;
    }
    
    else{
        var elements = this.querySelectorAll(query);
        if (elements && elements.length > 0 ) {
            if (once) {
                elements.forEach((element)=>{
                    element.addEventListener(actionEvent, (event) => action.call(element,element,event),{once:true});
                });
            }
            else {
                elements.forEach((element)=>{
                    element.addEventListener(actionEvent, (event) => action.call(element,element,event));
                });
            }
        }
    }
}

/**
 * 
 * @param {string} query 
 * @param {string} actionEvent 
 * @param {any} action 
 * @param {bool} once 
 * @returns {null | HTMLElement | NodeList | void}
 */
function Qst(query, actionEvent = null, action = null,once = false) {
    if (actionEvent === null || action === null) {
        if (query[0] == '*') {
            var element = document.querySelectorAll(query.substring(1,query.length));
        } 
        else {
            var element = document.querySelector(query);
        } 
        return element;
    }
    
    else{
        var elements = document.querySelectorAll(query);
        if (elements && elements.length > 0 ) {
            if (once) {
                elements.forEach((element)=>{
                    element.addEventListener(actionEvent, (event) => action.call(element,element,event),{once:true});
                });
            }
            else {
                elements.forEach((element)=>{
                    element.addEventListener(actionEvent, (event) => action.call(element,element,event));
                });
            }
        }
    }
}

function QSst (query, actionEvent = null, action = null,once= false) {
    if (actionEvent === null || action === null) {
        if (query[0] == '*') {
            var element = this.querySelectorAll(query.substring(1,query.length));
        } 
        else {
            var element = this.querySelector(query);
        } 
        return element;
    }
    
    else{
        var elements = this.querySelectorAll(query);
        if (elements && elements.length > 0 ) {
            if (once) {
                elements.forEach((element)=>{
                    element.addEventListener(actionEvent, (event) => action.call(element,element,event),{once:true});
                });
            }
            else {
                elements.forEach((element)=>{
                    element.addEventListener(actionEvent, (event) => action.call(element,element,event));
                });
            }
        }
    }
}
/**
 * 
 * @param {string} query 
 * @param {Function} func 
 * @returns {void}
 */
function QsForeach(query, func) {
    let elements = document.querySelectorAll(query)
    elements?.forEach(func);
}
/**
 * 
 * @param {string} query 
 * @param {Function} func 
 * @returns {void}
 */
function QSsForeach(query, func) {
    let elements = this.querySelectorAll(query)
    elements?.forEach(func);
}

function hideThis() {
    if (this instanceof NodeList) {
        this.forEach((each)=>{
            each.style.display = 'none';
        });
    }
    else {
        this.style.display = 'none';
    } 
}
removeThis = function (obg,query) {
    var efemlist = []
    for (var ele of obg) {
        if (ele !== query){
            efemlist.push(ele)
        }
    }
    return efemlist;
}
function addClass (classval) { 
    if (this instanceof NodeList) {
        this.forEach((each) => {
            addClassesToElement(each, classval);
        });
    }
    else {
        addClassesToElement(this, classval);
    }
}
HTMLElement.prototype.containsClass = function (theClass) {
    if (this.classList.contains(theClass)) {
        return true;
    }
    else {
        return false;
    }
}

function addClassesToElement(element, classval) {
    var classesArray = classval.split(' ');
    classesArray.forEach((singleClass) => {
        element.classList.add(singleClass);
    });
}

function isValidMail (val) {
    var emailPattern = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailPattern.test(val)
}

HTMLElement.prototype.containChild = function (query){
    var liste = this.childNodes
    var comp = 0;
    for (var ele = 0; ele < liste.length; ele++) {
        if (liste[ele] == query) {
            comp++
        }
    }
    if (comp > 0) {
        return true
    }
    else {
        return false
    } 
}

function removeClass (classval) {
    if (this instanceof NodeList) {
        this.forEach((each) => {
            removeClassesFromElement(each, classval);
        });
    } else {
        removeClassesFromElement(this, classval);
    }
}

function replaceClass (currentClass,newClass,timeout=0) {
    if (this instanceof NodeList) {
        this.forEach((each) => {
            each.removeClass(currentClass)
            setTimeout(() => {
                each.addClass(newClass)
            }, timeout);
        });
    } else {
        this.removeClass(currentClass)
        setTimeout(() => {
            this.addClass(newClass)
        }, timeout);
    }
}

function removeClassesFromElement(element, classval) {
    var classesArray = classval.split(' ');
    classesArray.forEach((singleClass) => {
        element.classList.remove(singleClass);
    });
}


HTMLElement.prototype.clearText = function () {
    if (this instanceof NodeList) {
        this.forEach((each)=>{
            each.innerText = '';
        });
    }
    else {
        this.innerText = '';
    }
}
function showThis(type = 'block') {
    if (this instanceof NodeList) {
        this.forEach((each)=>{
            each.style.display = type;
        });
    }
    else {
        this.style.display = type;
    }
}
function getData (value) {
    data_value = this.getAttribute('data-' + value);
    return data_value;
}

function setData (dataValue,value) {
    data_value = this.setAttribute('data-' + dataValue,value);
    return true;
}

class getURI {
    constructor () {
        this.url = window.location.href;
        return this.url;
    }
}

String.prototype.thisParams = function () {
    var params = {};
    var queryString = this.split('?')[1];
    if (queryString) {
        var keyValuePairs = queryString.split('&');
        for (var i = 0; i < keyValuePairs.length; i++) {
            var keyValue = keyValuePairs[i].split('=');
            var key = decodeURIComponent(keyValue[0]);
            var value = decodeURIComponent(keyValue[1]);
            params[key] = value;
        }
    }
    return params;
}
String.prototype.thisURIOnly = function (){
    var queryString = this.split('?')[0];
    // if (decode) {
    //     queryString = decodeURIComponent(queryString);
    // }
    return queryString;
}

refactAsParamURI = function (Obj) {
    // var params = getParamsFromURL();
    var linkHref = '';
    // Ajouter les paramètres de l'URL active au lien
    // //console.log(this);
    if (Object.keys(Obj).length > 0) {
        linkHref += '?' + Object.entries(Obj).map(([key, value]) => encodeURIComponent(key) +'='+encodeURIComponent(value)).join('&');
    }
    return linkHref;
}

globalThis;
var tlGET = {
    currentURL : window.location.href,
    currentURLMapParam : window.location.href.thisParams(),
    currentURLStringParam : {
        full: stringfyParam(window.location.href.thisParams(),'&',true),
        simple: stringfyParam(window.location.href.thisParams(),'&')
    },
    getnx : function (a,b) {
        return a*b;
    },
}

function valueThis (val='') {
    this.value = val;
    return true;
}

function textThis (val,mode=null) {
    if (mode) {
        if (mode === "+" || mode === "a") {
            this.innerText += val;
        }
        this.innerText = val;
    }
    else {
        this.innerText = val;
    }
    return true;
}
function htmlThis (val,mode=null) {
    if (mode) {
        if (mode === "+" || mode === "a") {
            this.innerHTML += val;
        }
        this.innerHTML = val;
    }
    else {
        this.innerHTML = val;
    }
    return true;
}
function thisParent (nParent = 1) {
    if (nParent === 1) {
        return this.parentElement;
    }
    else if (nParent == 2) {
        return this.parentElement.parentElement;
    }
    else if (nParent == 3) {
        return this.parentElement.parentElement.parentElement;
    }
    else if (nParent == 4) {
        return this.parentElement.parentElement.parentElement.parentElement;
    }
    else if (nParent == 5) {
        return this.parentElement.parentElement.parentElement.parentElement.parentElement;
    }
    else if (nParent == 6) {
        return this.parentElement.parentElement.parentElement.parentElement.parentElement.parentElement;
    }
    else if (nParent == 7) {
        return this.parentElement.parentElement.parentElement.parentElement.parentElement.parentElement.parentElement;
    }
    else if (nParent == 8) {
        return this.parentElement.parentElement.parentElement.parentElement.parentElement.parentElement.parentElement.parentElement;
    }
    else if (nParent == 9) {
        return this.parentElement.parentElement.parentElement.parentElement.parentElement.parentElement.parentElement.parentElement.parentElement;
    }
    else if (nParent == 10) {
        return this.parentElement.parentElement.parentElement.parentElement.parentElement.parentElement.parentElement.parentElement.parentElement.parentElement;
    }
    
}
function thisNextSibling (nSib = 1) {
    if (nSib === 1) {
        return this.nextElementSibling;
    }
    else if (nSib == 2) {
        return this.nextElementSibling.nextElementSibling;
    }
    else if (nSib == 3) {
        return this.nextElementSibling.nextElementSibling.nextElementSibling;
    }
    else if (nSib == 4) {
        return this.nextElementSibling.nextElementSibling.nextElementSibling.nextElementSibling;
    }
    else if (nSib == 5) {
        return this.nextElementSibling.nextElementSibling.nextElementSibling.nextElementSibling.nextElementSibling;
    }
    else if (nSib == 6) {
        return this.nextElementSibling.nextElementSibling.nextElementSibling.nextElementSibling.nextElementSibling.nextElementSibling;
    }
    else if (nSib == 7) {
        return this.nextElementSibling.nextElementSibling.nextElementSibling.nextElementSibling.nextElementSibling.nextElementSibling.nextElementSibling;
    }
    else if (nSib == 8) {
        return this.nextElementSibling.nextElementSibling.nextElementSibling.nextElementSibling.nextElementSibling.nextElementSibling.nextElementSibling.nextElementSibling;
    }
    else if (nSib == 9) {
        return this.nextElementSibling.nextElementSibling.nextElementSibling.nextElementSibling.nextElementSibling.nextElementSibling.nextElementSibling.nextElementSibling.nextElementSibling;
    }
    else if (nSib == 10) {
        return this.nextElementSibling.nextElementSibling.nextElementSibling.nextElementSibling.nextElementSibling.nextElementSibling.nextElementSibling.nextElementSibling.nextElementSibling.nextElementSibling;
    }
    
}
function thisPreviousSibling (nSib = 1) {
    if (nSib === 1) {
        return this.previousElementSibling;
    }
    else if (nSib == 2) {
        return this.previousElementSibling.previousElementSibling;
    }
    else if (nSib == 3) {
        return this.previousElementSibling.previousElementSibling.previousElementSibling;
    }
    else if (nSib == 4) {
        return this.previousElementSibling.previousElementSibling.previousElementSibling.previousElementSibling;
    }
    else if (nSib == 5) {
        return this.previousElementSibling.previousElementSibling.previousElementSibling.previousElementSibling.previousElementSibling;
    }
    else if (nSib == 6) {
        return this.previousElementSibling.previousElementSibling.previousElementSibling.previousElementSibling.previousElementSibling.previousElementSibling;
    }
    else if (nSib == 7) {
        return this.previousElementSibling.previousElementSibling.previousElementSibling.previousElementSibling.previousElementSibling.previousElementSibling.previousElementSibling;
    }
    else if (nSib == 8) {
        return this.previousElementSibling.previousElementSibling.previousElementSibling.previousElementSibling.previousElementSibling.previousElementSibling.previousElementSibling.previousElementSibling;
    }
    else if (nSib == 9) {
        return this.previousElementSibling.previousElementSibling.previousElementSibling.previousElementSibling.previousElementSibling.previousElementSibling.previousElementSibling.previousElementSibling.previousElementSibling;
    }
    else if (nSib == 10) {
        return this.previousElementSibling.previousElementSibling.previousElementSibling.previousElementSibling.previousElementSibling.previousElementSibling.previousElementSibling.previousElementSibling.previousElementSibling.previousElementSibling;
    }
    
}

function copyAdress(copySrc) {
    var Copyresponse
    return new Promise((resolve, reject)=>{
        var textarea = document.createElement("textarea");
        textarea.value = copySrc;
        document.body.appendChild(textarea);
        // Selectionné le texte dans l'élément
        textarea.select();
        // exécuter la copy
        var copySuccess = document.execCommand("copy");
        
        // Supprimer l'élément tamporaire
        document.body.removeChild(textarea);
        if (copySuccess) {
            Copyresponse = true;
            resolve(true)
        }
        else{
            Copyresponse = false;
            reject(false)
        }
    })
}

/**
 * 
 * @param {HTMLElement} element 
 * @param {String} type 
 * @param {bool} isHtml 
 */
function navigatorPasteIn(element,type="input",isHtml=false) {

    navigator.permissions.query({name: 'clipboard-read'}).then(result => {
        if (result.state === 'granted' || result.state === 'prompt') {
            navigator.clipboard.readText()
                .then((text) => {
                    
                    if (type == "input") {
                        // Récupérer le texte du presse-papiers et le coller dans l'input
                        element.value = text;
                    }
                    else {
                        if (isHtml) {
                            element.htmlThis(text)
                        }
                        else {
                            element.textThis(text)
                        }
                    }
                    
                
                })
                .catch(err => {
                    console.error('Erreur lors de la lecture du presse-papiers', err);
                });
                return true
        } else {
            // Si l'API Clipboard n'est pas prise en charge, informer l'utilisateur
            alert("vous n'avez pas permis le collage.");
            return false;
        }
    })
}

/**
 * 
 * @param {HTMLElement} element 
 * @param {String} type 
 * @param {bool} isHtml 
 */
function pasteIn(element, type="input", isHtml=true) {
    // Sélectionnez l'input
    var input = document.getElementById("myInput");
  
    // Sélectionnez le texte dans le presse-papiers
    var clipboardContent = window.clipboardData.getData("Text");
    if (type == "input" || type === "textarea") {
        element.focus()
        // Collez le texte dans l'input
        document.execCommand("insertText", false, clipboardContent);
    }
    else {
        if (isHtml) {
            element.htmlThis(clipboardContent)
        }
        else {
            element.textThis(clipboardContent)
        }
    }
    
}

function getRandomUniqueNumber (min=0, max) {
    var array = [];
    var n = Math.floor(Math.random()*(max-min+1))+min;
    while (array.length<(max-min)+1) {
        while (array.includes(n)) {
            n = Math.floor(Math.random()*(max-min+1))+min;
            // //console.log(n);
        }
        array.push(n);
    }

    return array;
}

function tl_rend (min=0, max) {
    var n = Math.floor(Math.random()*(max-min+1))+min;
    return n;
}
function bodyAppend(child) {
    document.body.appendChild(child);
}
function bodyRemove(child) {
    document.body.removeChild(child);
}
function tl_generateAlphanum(prefix="",length) {
    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    let result = prefix;
    
    for (let i = 0; i < length; i++) {
        const randomIndex = Math.floor(Math.random() * characters.length);
        result += characters[randomIndex];
    }

    return result;
}


/**
 * 
 * @param {string} query 
 * @param {object} options 
 * @returns {HTMElement}
 */
function createdElement(query,{addclass=null,addid=null,addvalue=null,addtext=null,addhtml=null}) {
    var elementCreate = document.createElement(query);
    if (addclass != null) {
        elementCreate.addClass(addclass);
    }
    if (addid != null) {
        elementCreate.setAttribute('id',addid);
    }
    if (addvalue != null) {
        elementCreate.valueThis(addvalue);
    }
    if (addtext != null) {
        elementCreate.textThis(addtext);
    }
    if (addhtml != null) {
        elementCreate.htmlThis(addhtml);
    }
    return elementCreate;
}

function getRealStyle (element) {
    return document.defaultView.getComputedStyle(element);
}

HTMLElement.prototype.tlWriting = async function(texts,speed=50, textChangeSpeed=200,reverse = false,{time=1000,count=1,startDelay=0}) {
    await futureBuilder(startDelay)
    const element = this;
    let textIndex = 0;
    let charIndex = 0;
    var finished = true;
    let focus = createdElement("span",{addclass: "focusWrite tl_ml-5"})
    let contend = createdElement("span",{addclass: "tlWriteMain"})
    element.appendChild(contend)
    element.appendChild(focus)
    async function typeText() {
        
        if (textIndex < texts.length) {
            const currentText = texts[textIndex];
            contend.textContent = currentText.slice(0, charIndex);
            charIndex++;
            
            if (charIndex <= currentText.length) {
                await futureBuilder(speed);
                typeText();
            } else {
                if (!reverse) {
                    textIndex++;
                    charIndex = 0;
                    await futureBuilder(textChangeSpeed);
                    typeText() // Délai entre les textes
                }
                else {
                    //supprimer les lettres du texte actuel un par un avec clearText avant de pas au text suivant
                    charIndex = reverse ? 0 : currentText.length;
                    await futureBuilder(textChangeSpeed)
                    clearText ();
                }
            }
        }
        else {
            if (finished) {
                initWrite()
            }
        }
        
    }
    async function clearText() {
        const currentText = contend.textContent;
        if (currentText.length > 0) {
            contend.textContent = currentText.slice(0, -1);
          await futureBuilder(speed)
          clearText()
        } else {
          textIndex++;
          charIndex = 0;
          await futureBuilder(textChangeSpeed)
          typeText() // Commence à écrire le prochain texte
        }
    }
    var compteur = 0;
    async function initWrite() {
        if (typeof count !== "string") {
            compteur++;
            if (compteur <= count){
                finished = true
                textIndex = 0
                charIndex = 0
                await futureBuilder(time);
                typeText();
            }
            else {
                await futureBuilder(1000);
                element.removeChild(focus)
                finished = false;
            }
        }
        else {
            if (count.toLowerCase() == "infinite") {
                finished = true
                textIndex = 0
                charIndex = 0
                await futureBuilder(time);
                typeText();
            }
        }
    }
    initWrite()
};



class Toast {
    body = document.body
    delay = 1000
    toast = ""
    constructor (element = this.body) {
        this.element = element
        if (!this.element.containsClass("tl_position-relative")){
            this.element.styleThis("position","relative")
            this.element.addClass("tl_Position-relative")
        }
    }
    init () {
        this.toast = createdElement('div',{
            addclass: "toast tl_shadow-1",
        })
        if (this.element == this.body) {
            bodyAppend(this.toast)
        }
        else {
            this.element.appendChild(this.toast)
        }
    }
    async show (message,delayUtil=1000) {
        this.init()
        this.toast.htmlThis(message)
        this.toast.addClass("toast-active")
        await futureBuilder(delayUtil)
        this.toast.removeClass("toast-active")
        await futureBuilder(300)
        this.close()
    }

    close () {
        this.element.removeChild(this.toast)
    }
}
/**
 * @param {string} actionName 
 * @returns {bool} 
 */
function hasTlaction (actionName) {
    return this.hasAttribute("tl-"+actionName);
}
/**
 * @param {string} actionName 
 * @param {string} value 
 */
function setTlaction (actionName, value) {
    this.setAttribute("tl-"+actionName,value);
}
/**
 * 
 * @param {string} actionName 
 * @returns {string}
 */
function getTlaction (actionName) {
    return this.getAttribute("tl-"+actionName);
}
/**
 * 
 * @param {string} actionName 
 */
function removeTlaction (actionName) {
    this.removeAttribute("tl-"+actionName);
}

/**
 * Generates a random alphanumeric string of specified length with optional prefix and suffix.
 *
 * @param {number} length - The length of the alphanumeric string to generate.
 * @param {string} [prefix=""] - The prefix to be added to the beginning of the generated string.
 * @param {string} [suffix=""] - The suffix to be added to the end of the generated string.
 * @returns {string} - The generated string consisting of the prefix, random alphanumeric string, and suffix.
 */
function tlgenAlphaNum(length, prefix = "", suffix = "") {
    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    let result = '';
    
    // Generate random alphanumeric string
    for (let i = 0; i < length; i++) {
        const randomIndex = Math.floor(Math.random() * characters.length);
        result += characters[randomIndex];
    }

    // Return the final string with prefix and suffix
    return prefix + result + suffix;
}


String.prototype._tlf = _tlf;
HTMLElement.prototype.setTlaction = setTlaction;
HTMLElement.prototype.hasTlaction = hasTlaction;
HTMLElement.prototype.getTlaction = getTlaction;
HTMLElement.prototype.removeTlaction = removeTlaction;
HTMLElement.prototype.hideThis = hideThis;
HTMLElement.prototype.showThis = showThis;
NodeList.prototype.hideThis = hideThis;
NodeList.prototype.showThis = showThis;
HTMLElement.prototype.getData = getData;
HTMLElement.prototype.setData = setData;
HTMLElement.prototype.textThis = textThis;
HTMLElement.prototype.htmlThis = htmlThis;
HTMLElement.prototype.thisParent = thisParent;
HTMLElement.prototype.thisNextSibling = thisNextSibling;
HTMLElement.prototype.thisPreviousSibling = thisPreviousSibling;
HTMLElement.prototype.QSs = QSs;
HTMLElement.prototype.QSst = QSst;
HTMLElement.prototype.QSsForeach = QSsForeach;
HTMLElement.prototype.valueThis = valueThis;
HTMLElement.prototype.replaceClass = replaceClass;
NodeList.prototype.replaceClass = replaceClass;
HTMLElement.prototype.addClass = addClass;
NodeList.prototype.addClass = addClass;
HTMLElement.prototype.removeClass = removeClass;
NodeList.prototype.removeClass = removeClass;



HTMLElement.prototype.setAttr = HTMLElement.prototype.setAttribute
HTMLElement.prototype.getAttr = HTMLElement.prototype.getAttribute
HTMLElement.prototype.removeAttr = HTMLElement.prototype.removeAttribute
HTMLElement.prototype.hasAttr = HTMLElement.prototype.hasAttribute

class CustomSelect {
    constructor(container=null, options, params = {}) {
        if (!container) {
            return;
        }
        this.container = container;  // Le conteneur dans lequel on insère le select
        this.options = options.map(option => ({
            ...option,
            // Ajouter des valeurs par défaut pour prefix et suffix si non définis
            prefix: option.prefix || null,
            suffix: option.suffix || null,
            selected: option.selected || false,
        }));  // Mise à jour des options avec des valeurs par défaut pour prefix et suffix
        this.defaultText = params.defaultText || 'Sélectionnez une option'; // Le texte par défaut
        this.selectedValue = null;   // Valeur sélectionnée
        this.value = this.selectedValue
        this.containerStyle = params.containerStyle || {}; // Style personnalisé pour le conteneur
        this.triggerStyle = params.triggerStyle || {}; // Style personnalisé pour le trigger
        this.optionListStyle = params.optionListStyle || {}; // Style personnalisé pour le wrapper des options
        this.optionStyle = params.optionStyle || {}; // Style personnalisé pour les options
        this.containerClass = params.containerClass || ''; // Classe CSS personnalisée pour le conteneur
        this.triggerClass = params.triggerClass || ''; // Classe CSS personnalisée pour le trigger
        this.optionClass = params.optionClass || ''; // Classe CSS personnalisée pour les options
        this.openClass = 'open'; // Classe CSS pour l'état ouvert
        this.selectedClass = params.selectedClass || 'selected'; // Classe CSS pour l'élément sélectionné
        this._createSelect(); // Crée le select personnalisé
        this._triggerDefaultSelection();  // Initialiser la sélection par défaut
        
    }
    
    // Méthode pour ajouter des classes à un élément sans remplacer les classes existantes
    _addClasses(element, baseClasses, customClasses) {
        const classes = [baseClasses, customClasses].filter(Boolean).join(' ');
        element.classList.add(...classes.split(' '));
    }
    
    _triggerDefaultSelection() {
        const selectedOptionElement = this.optionsList.querySelector(`[selected]`);
        const defaultOption = selectedOptionElement || this.optionsList.querySelector('.custom-option');
        if (defaultOption) {
            defaultOption.click();  // Simule le clic sur l'option sélectionnée
        }
    }

    // Méthode pour créer et ajouter le select personnalisé
    _createSelect() {
        // Créer la structure HTML du select personnalisé
        this.customSelect = document.createElement('div');
        this.customSelect.classList.add('custom-select');
        this._addClasses(this.customSelect, 'custom-select', this.containerClass); // Ajouter les classes personnalisées

        // Appliquer les styles personnalisés au conteneur
        for (let property in this.containerStyle) {
            this.customSelect.style[property] = this.containerStyle[property];
        }
        
        // Créer l'icône flèche
        this.arrowIcon = document.createElement('div');
        this.arrowIcon.classList.add('arrow-icon');
        this.arrowIcon.innerHTML = '&#9660;';  // Icône flèche vers le bas
        
        // Créer le trigger (élément visible)
        this.trigger = document.createElement('div');
        this.trigger.classList.add('custom-select-trigger');
        this._addClasses(this.trigger, 'custom-select-trigger', this.triggerClass); // Ajouter les classes personnalisées
        this.trigger.textContent = this.defaultText;
        
        // Appliquer les styles personnalisés au trigger
        for (let property in this.triggerStyle) {
            this.trigger.style[property] = this.triggerStyle[property];
        }
        
        // Créer la liste des options
        this.optionsList = createdElement('div',{addclass:'custom-options'});
        // Appliquer les styles personnalisés au trigger
        for (let property in this.optionListStyle) {
            this.optionsList.style[property] = this.optionListStyle[property];
        }
        
        this.options.forEach(option => {
            const optionElement = createdElement('div',{addclass:'custom-option'});
            this._addClasses(optionElement, 'custom-option', this.optionClass); // Ajouter les classes personnalisées
            
            // Appliquer les styles personnalisés aux options
            for (let property in this.optionStyle) {
                optionElement.style[property] = this.optionStyle[property];
            }
            if (option.selected) {
                optionElement.setAttribute("selected","true")
            }
            // Ajouter le préfixe, le texte, puis le suffixe
            if (option.prefix) {
                if (typeof option.prefix === 'string') {
                    optionElement.innerHTML += option.prefix;  // Ajouter le préfixe en HTML
                } else if (option.prefix instanceof HTMLElement) {
                    optionElement.appendChild(option.prefix);  // Ajouter l'élément HTML comme préfixe
                }
            }

            optionElement.innerHTML += option.label; // Ajouter le texte de l'option
            
            if (option.suffix) {
                if (typeof option.suffix === 'string') {
                    optionElement.innerHTML += option.suffix;  // Ajouter le suffixe en HTML
                } else if (option.suffix instanceof HTMLElement) {
                    optionElement.appendChild(option.suffix);  // Ajouter l'élément HTML comme suffixe
                }
            }
            
            optionElement.setAttribute('value', option.value);
            this.optionsList.appendChild(optionElement);
        });
        
        // Ajouter les éléments au container
        this.customSelect.appendChild(this.arrowIcon);
        this.customSelect.appendChild(this.trigger);
        this.customSelect.appendChild(this.optionsList);
        this.container.appendChild(this.customSelect);

        // Gérer les événements
        this._addEventListeners();
    }
    
    // Méthode pour ajouter les écouteurs d'événements
    _addEventListeners() {
        // Ouvrir/fermer le select au clic sur le trigger
        this.trigger.addEventListener('click', (event) => {
            this._toggleDropdownDirection();
            this.customSelect.classList.toggle(this.openClass);
            const optChildren = this.optionsList.children;
            const h = parseFloat(getRealStyle(optChildren[0]).height.replace("px",""))*optChildren.length+"px";
            if (this.customSelect.containsClass(this.openClass)) {
                this.optionsList.styleThis("height",h)
            }
            else {
                this.optionsList.styleThis("height",0)
            }
            event.stopPropagation(); // Empêche la propagation au document
        });

        // Sélectionner une option
        this.optionsList.querySelectorAll('.custom-option').forEach(option => {
            option.addEventListener('click', (event) => {
                this.trigger.innerHTML = option.innerHTML; // Mettre à jour le texte du trigger
                this.selectedValue = option.getAttribute('value'); // Récupérer la valeur
                this.value = this.selectedValue; // Récupérer la valeur
                this.customSelect.classList.remove(this.openClass); // Fermer le menu
                event.stopPropagation(); // Empêche la propagation au document
            });
        });
        
        // Fermer le select si clic extérieur
        window.addEventListener('click', (event) => {
            if (!this.customSelect.contains(event.target)) {
                this.customSelect.classList.remove(this.openClass);
            }
        });
    }
    
    // Nouvelle méthode pour déterminer la direction d'ouverture du menu
    _toggleDropdownDirection() {
        const rect = this.customSelect.getBoundingClientRect();
        const windowHeight = window.innerHeight;
        
        // Calculer l'espace disponible en dessous du select
        const spaceBelow = windowHeight - rect.bottom;
        
        if (spaceBelow < 250) {
            // Si l'espace est insuffisant, ouvrir vers le haut
            this.optionsList.classList.remove('down');
            this.optionsList.classList.add('up');
        } else {
            // Ouvrir vers le bas
            this.optionsList.classList.remove('up');
            this.optionsList.classList.add('down');
        }
    }
    
    // Méthode pour obtenir la valeur sélectionnée
    getValue () {
        return this.value;
    }
}
let TLStyleSheet = document.createElement("style");

function loadStyle(root = null) {
    let allEl = root ? root.QSst('**') : Qst("**");

    const attrToCssMap = [
        ["display", "display", "d"],
        ["backdrop-filter", "backdrop-filter", "bf"],
        ["background", "background", "bg"],
        ["background-position", "background-position", "bg-position"],
        ["background-size", "background-size", "bg-size"],
        ["background-repeat", "background-repeat", "bg-repeat"],
        ["background-clip", "background-clip", "bg-clip"],
        ["background-image", "background-image", "bg-image"],
        ["background-origin", "background-origin", "bg-origin"],
        ["background-position-x", "background-position-x", "bg-position-x"],
        ["background-position-y", "background-position-y", "bg-position-y"],
        ["overflow", "overflow"],
        ["overflow-x", "overflow-x"],
        ["overflow-y", "overflow-y"],
        ["text-align", "text-align"],
        ["pointer-events", "pointer-events"],
        ["gap", "gap"],
        ["align-items", "align-items", "ai"],
        ["justify-content", "justify-content", "jc"],
        ["flex-direction", "flex-direction", "flex"],
        ["animation", "animation"],
        ["animation-delay", "animation-delay", "animation-d"],
        ["transition", "transition", "t"],
        ["transition-delay", "transition-delay", "td", "transition-d"],
        ["box-shadow", "box-shadow", "shadow"],
        ["box-sizing", "box-sizing", "sizing"],
        ["font-family", "font-family", "family"],
        ["opacity", "opacity"],
        ["font-size", "font-size", "fs"],
        ["text-decoration", "text-decoration", "decoration"],
        ["text-transform", "text-transform"],
        ["font-weight", "font-weight", "fw"],
        ["top", "top"],
        ["left", "left"],
        ["right", "right"],
        ["bottom", "bottom"],
        ["color", "color"],
        ["position", "position"],
        ["border", "border"],
        ["border-color", "border-color"],
        ["border-width", "border-width"],
        ["border-radius", "border-radius"],
        ["outline", "outline"],
        ["outline-color", "outline-color"],
        ["outline-width", "outline-width"],
        ["padding", "padding", "p"],
        ["padding-left", "padding-left", "pl"],
        ["padding-right", "padding-right", "pr"],
        ["padding-top", "padding-top", "pt"],
        ["padding-bottom", "padding-bottom", "pb"],
        ["margin", "margin", "m"],
        ["margin-left", "margin-left", "ml"],
        ["margin-right", "margin-right", "mr"],
        ["margin-top", "margin-top", "mt"],
        ["margin-bottom", "margin-bottom", "mb"],
        ["width", "width", "w"],
        ["min-width", "min-width", "min-w"],
        ["max-width", "max-width", "max-w"],
        ["height", "height", "h"],
        ["min-height", "min-height", "min-h"],
        ["max-height", "max-height", "max-h"],
        ["transform", "transform", "tf"],
        ["cursor", "cursor"],
        ["z-index", "z-index"],
    ];

    if (allEl && allEl.length > 0) {
        allEl.forEach((el, index) => {
            if (!el.hasAttribute("tl-mode")) return;

            el.removeAttr("tl-mode");
            const className = "tl_scs_commit_" + Date.now().toString().slice(4) + index;
            let cssRules = [];

            // Traitement des cas spéciaux
            if (el.hasAttribute("flex-col")) {
                el.removeAttr("flex-col");
                cssRules.push("flex-direction:column");
            }
            if (el.hasAttribute("flex-row")) {
                el.removeAttr("flex-row");
                cssRules.push("flex-direction:row");
            }
            if (el.hasAttribute("center")) {
                el.removeAttr("center");
                cssRules.push("display:flex", "align-items:center", "justify-content:center");
            }
            if (el.hasAttribute("col")) {
                el.removeAttr("col");
                cssRules.push("display:flex", "width:100%", "flex-direction:column");
            }
            if (el.hasAttribute("row")) {
                el.removeAttr("row");
                cssRules.push("display:flex", "width:100%", "flex-direction:row");
            }
            if (el.hasAttribute("circle")) {
                el.removeAttr("circle");
                cssRules.push("border-radius:50%");
            }

            // Mapping des attributs en règles CSS
            attrToCssMap.forEach(([cssProp, ...attrNames]) => {
                for (let attr of attrNames) {
                    if (el.hasAttribute(attr)) {
                        cssRules.push(`${cssProp}:${el.getAttr(attr)}`);
                        el.removeAttr(attr);
                        break;
                    }
                }
            });

            // padding-h, padding-v
            if (el.hasAttribute("padding-h") || el.hasAttribute("ph")) {
                const val = el.getAttr("padding-h") || el.getAttr("ph");
                el.removeAttr("padding-h"); el.removeAttr("ph");
                cssRules.push(`padding-left:${val}`, `padding-right:${val}`);
            }
            if (el.hasAttribute("padding-v") || el.hasAttribute("pv")) {
                const val = el.getAttr("padding-v") || el.getAttr("pv");
                el.removeAttr("padding-v"); el.removeAttr("pv");
                cssRules.push(`padding-top:${val}`, `padding-bottom:${val}`);
            }
            // margin-h, margin-v
            if (el.hasAttribute("margin-h") || el.hasAttribute("mh")) {
                const val = el.getAttr("margin-h") || el.getAttr("mh");
                el.removeAttr("margin-h"); el.removeAttr("mh");
                cssRules.push(`margin-left:${val}`, `margin-right:${val}`);
            }
            if (el.hasAttribute("margin-v") || el.hasAttribute("mv")) {
                const val = el.getAttr("margin-v") || el.getAttr("mv");
                el.removeAttr("margin-v"); el.removeAttr("mv");
                cssRules.push(`margin-top:${val}`, `margin-bottom:${val}`);
            }

            // Génération de la classe CSS
            TLStyleSheet.innerText += `.${className}{${cssRules.join(";")}}`;

            // OnHover
            if (el.hasAttribute("onhover")) {
                let hoverVal = el.getAttr("onhover");
                el.removeAttr("onhover");
                if (!hoverVal.endsWith(";")) hoverVal += ";";
                TLStyleSheet.innerText += `.${className}:hover{${hoverVal.replace(/\$/g, ":")}}`;
            }

            el.addClass(className);
        });
    }

    const head = Qst("head");
    if (head instanceof HTMLElement) {
        head.appendChild(TLStyleSheet);
    }
}

/**
 * 
 * @param {Function} func fonction for document DOMContentLoaded event
 */
function whenReady ( func = ()=>{} ) {
    document.addEventListener('DOMContentLoaded', (e)=>{
        let fields = Qst("*tl-field")
        
        if (fields && fields.length > 0) {
            fields.forEach(field => {
                let attr = field.attributes
                let lab = createdElement("label",{addtext:field.getAttr('placeholder')})
                let inp = createdElement("input",{})
                inp.addEventListener('focus', (e)=>{
                    field.setAttr("focus-mode",true)
                    field.setAttr("fill-mode",true)
                })
                inp.addEventListener('blur', (e)=>{
                    let cond = inp.value.length > 0
                    if (!cond) {
                        field.removeAttr("fill-mode")
                    }
                    field.removeAttr("focus-mode")
                })
                lab.setAttr('for',field.getAttr('id'))
                for (let att of attr ) {
                    if (att.name != "placeholder") {
                        inp.setAttr(att.name,att.value)
                    }
                    // retour += "*:*,"._tlf(att.name,att.value)
                }
                field.appendChild(lab)
                field.appendChild(inp)
            })
        }
        func(e);
    })
}

//QRCode  gene from gitHub js


//======================================================EXEMPLE DE MANIPULATION D'URL=========================================================



// let rowlink = document.querySelectorAll('.table-row-link');
// var modal = Qs('.code_modal');
// window.onclick = function(event){
//     if(event.target == modal){
//         modal.styleThis('display','none');
//         removeURLParameter('user_id');
//     }
// }
// Vérifier si l'URL actuelle contient des paramètres
// var urlAvecParametres = window.location.href;

// // Fonction de rappel pour l'événement beforeunload
// function removeURLParameter(parameter) {
//     var urlParams = new URLSearchParams(window.location.search);
//     urlParams.delete(parameter);
//     var newURL = window.location.pathname + '?' + urlParams.toString();
//     window.history.replaceState({}, '', newURL);
// }
// let personnalReload = false;
// // Ajouter l'événement beforeunload à la fenêtre
// window.addEventListener('beforeunload',()=>{
//     personnalReload = true;
//     removeURLParameter('user_id');
// } );

// Qs('.edit_td','click',(e)=>{
    
//     Id = getData(e,'user_id');
//     WillbeId.value = Id;
//     // JSSend('GET', '', { user_id: Id }, function(success, response) {
//     //     if (success) {
            
//     //     } else {
//     //     // Gérez l'erreur de requête AJAX
//     //     console.error(response);
//     //     }
//     // });
//     var nouvelleId = Id;
            
//             // Obtenir les paramètres de l'URL actuelle
//             var urlParams = new URLSearchParams(window.location.search);
            
//             // Vérifier si d'autres paramètres sont déjà présents dans l'URL
//             if (urlParams.toString() !== '') {
//                 // Ajouter le nouveau paramètre à l'URL existante
//                 if (urlParams.has('user_id')) {
//                 // Mettre à jour la valeur du paramètre 'id'
//                     urlParams.set('user_id', nouvelleId);
//                 } else {
//                     // Ajouter le paramètre 'id' à l'URL
//                     urlParams.append('user_id', nouvelleId);
//                 }
//             } else {
//                 // Ajouter le paramètre 'id' à une URL sans paramètres existants
//                 if (!personnalReload) {
//                 urlParams.set('user_id', nouvelleId);}
//             }
            
//             // Obtenir l'URL actuelle sans les paramètres
//             var urlActuelle = window.location.href.split('?')[0];
//             animat = Qs('.anim-container');
//             animat.styleThis('display','flex');
            
//             // Construire la nouvelle URL avec les paramètres mis à jour
//             var nouvelleUrl = urlActuelle + '?' + urlParams.toString();
            
//             // Mettre à jour l'URL sans rechargement de la page
//             window.history.pushState(null, null, nouvelleUrl);
//             window.location.reload(); 
//             window.onload = function() {
//                 // Afficher le modal après le rechargement complet de la page
//                 modal.styleThis('display','flex');
//             };

// });